# Q 2422 (한윤정이 이탈리아에 가서 아이스크림을 사먹는데)

<img src="https://img.shields.io/badge/Level-Silver 5-lightgrey"> <img src="https://img.shields.io/badge/Memory-1156%20KB-blue"> <img src="https://img.shields.io/badge/Time-4%20ms-brightgreen"> <img src="https://img.shields.io/badge/Length-456%20B-red"> <img src="https://img.shields.io/badge/Language-C-blueviolet">



> - N, M(1 ≤ N ≤ 200, 0 ≤ M ≤ 10,000) 을 입력받은 뒤 M의 값에 대하여 M의 입력값을 **a, b**로 하겠다.
>
>   200x200의 **exc배열**을 새로 만든 뒤 <u>a, b의 값을 인덱스로 하는 배열 값에 대입</u>해 준다.
>
>   ```c
>   int a, b;
>   scanf("%d %d", &a, &b);
>   exc[a][b] = b;
>   exc[b][a] = b;
>   ```
>
>   두 가지로 나누는 이유는 **a > b**일 경우와 a < b일 경우이다. 예를 들어 (1, 3)이 입력되었을 경우, (1, 3)에 3이 대입되고 (3, 1)에도 3이 입력되게 되는데 순서가 바뀌어도 제외되어야하는 경우는 <u>(1, 3)이나 (3, 1)이나 조합에 1과 3이 포함되어 있기 때문에 문제가 없다.</u> 입력이 반대로 (3, 1)인 경우에도 마찬가지다.
>
>   |  IDX  |  0   |   1   |   2   |   3   |   4   |
>   | :---: | :--: | :---: | :---: | :---: | :---: |
>   | **0** |  0   |   0   |   0   |   0   |   0   |
>   | **1** |  0   |   0   | **2** | **3** |   0   |
>   | **2** |  0   | **2** |   0   |   0   |   0   |
>   | **3** |  0   | **3** |   0   |   0   | **4** |
>   | **4** |  0   |   0   |   0   | **4** |   0   |
>
>   위 표는 문제의 예제 1을 이용하여 만들어본 배열이다.
>
>   
>
> - 이제 nC3의 모든 조합들 중 가능한 경우를 찾아야 하는데, 아이스크림의 종류 세 가지를 **i, j, k**라고 하자. 이 중에서 <u>두 가지가 위에서 생성했던 배열의 인덱스 값중 0이 아닌 값이 있을 경우 제외시켜주는 작업</u>을 해야 한다.
>
>   ```c
>   for (int i = 1; i <= n; i++)
>   	for (int j = i + 1; j <= n; j++)
>   	{
>   		if (exc[i][j] != 0) continue;
>   		for (int k = j + 1; k <= n; k++)
>   			if (exc[i][k] == 0 && exc[j][k] == 0) cnt++;
>   	}
>   ```
>
>   총 비교해야 하는 횟수는 3회이다. (i와 j, i와 k, j와 k)
>
>   i, j, k중에 i, j를 먼저 보면, 위 배열에서 <u>i, j를 인덱스로 하는 값이 0이 아닐 경우 continue</u>한다. 만약 0일 경우 다음 k를 비교해야 한다. 앞의 방법과 마찬가지로 해당 값을 인덱스로 하는 배열의 값이 모두 0일 경우 섞어 먹을 수 있는 경우이므로 카운트를 하나 더한다. 모든 반복문이 종료된 후 카운트를 출력한다.

